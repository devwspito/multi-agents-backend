import { Task, ITask, AgentType, IStory, ITeamMember, IEpic } from '../models/Task';
import { Repository } from '../models/Repository';
import { GitHubService } from './GitHubService';
import { NotificationService } from './NotificationService';
import { WorkVerificationService } from './WorkVerificationService';
import { AnalyticsService } from './AnalyticsService';
import { HookService } from './HookService';
import { CodeSnapshotService } from './code-tracking/CodeSnapshotService';

// üî• NEW SERVICES FOR REAL-TIME VISIBILITY AND RELIABLE GITHUB
import EnhancedAgentExecutor from './EnhancedAgentExecutor';
import ReliableGitHubService from './ReliableGitHubService';
import RealTimeLogger from './RealTimeLogger';
import ConsoleStreamer from './ConsoleStreamer';
import duplicationDetector from './DuplicationDetector';
import costEstimator from './CostEstimator';
import interactiveController from './InteractiveController';
import requirementsValidator from './RequirementsValidator';

import path from 'path';
import fs from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';

// New Architecture imports
import { OrchestrationContext } from './orchestration/Phase';
import { OrchestrationPipeline } from './orchestration/OrchestrationPipeline';
import { ProductManagerPhase } from './orchestration/ProductManagerPhase';
import { ProjectManagerPhase } from './orchestration/ProjectManagerPhase';
import { TechLeadPhase } from './orchestration/TechLeadPhase';
import { ApprovalPhase } from './orchestration/ApprovalPhase';
import { CostApprovalPhase } from './orchestration/CostApprovalPhase';
import { BranchSetupPhase } from './orchestration/BranchSetupPhase';
import { DevelopersPhase } from './orchestration/DevelopersPhase';
import { QAPhase } from './orchestration/QAPhase';
import { PRApprovalPhase } from './orchestration/PRApprovalPhase';
import { MergePhase } from './orchestration/MergePhase';
import { PRManagementService } from './github/PRManagementService';

const execAsync = promisify(exec);

/**
 * TeamOrchestrator - Orquestaci√≥n avanzada con team building din√°mico
 *
 * Features:
 * - Analiza complejidad de tarea (Product Manager)
 * - Crea stories din√°micamente y construye teams (Tech Lead)
 * - Spawns m√∫ltiples developers en paralelo
 * - Epic-based workflow (1 epic = 1 team = 1 branch = 1 PR)
 * - Integration testing per epic (QA)
 * - Merge coordination (detecta y resuelve conflictos)
 */
export class TeamOrchestrator {
  private readonly workspaceDir: string;
  private readonly githubService: GitHubService;
  private readonly workVerificationService: WorkVerificationService;
  private readonly analyticsService: AnalyticsService;
  private readonly hookService: HookService;
  private readonly prManagementService: PRManagementService;
  private readonly usePipelineArchitecture: boolean;

  constructor() {
    // üî• FIX: Use a persistent workspace directory in the project
    // NOT in /tmp which gets cleared!
    this.workspaceDir = process.env.AGENT_WORKSPACE_DIR ||
                        path.join(process.cwd(), '.agent-workspace');

    // Create workspace if it doesn't exist
    if (!fs.existsSync(this.workspaceDir)) {
      fs.mkdirSync(this.workspaceDir, { recursive: true });
      console.log(`üìÅ Created persistent workspace: ${this.workspaceDir}`);
    } else {
      console.log(`üìÅ Using existing workspace: ${this.workspaceDir}`);
    }

    this.githubService = new GitHubService(this.workspaceDir);
    this.workVerificationService = new WorkVerificationService();
    this.analyticsService = new AnalyticsService();
    this.hookService = new HookService(process.cwd());
    this.prManagementService = new PRManagementService(this.githubService);

    // Pipeline architecture is now the default and only option (Legacy removed)
    this.usePipelineArchitecture = true;
  }

  // ============================================================================
  // üÜï NEW ARCHITECTURE: Phase-by-Phase Execution (No Pipeline Recreation)
  // ============================================================================

  /**
   * Phase order - executed sequentially, one at a time
   */
  private readonly PHASE_ORDER = [
    'ProductManager',
    'ProductManagerApproval',
    'ProjectManager',
    'ProjectManagerApproval',
    'TechLead',
    'TechLeadApproval',
    'CostApproval',
    'BranchSetup',
    'Developers',
    'QA',
    'PRApproval',
    'Merge',
  ] as const;

  /**
   * Determine next phase to execute based on task state
   */
  private determineNextPhase(task: ITask): string | null {
    // If task is completed, no next phase
    if (task.status === 'completed') {
      return null;
    }

    // Check each phase in order and return the first incomplete one
    const pm = task.orchestration.productManager;
    const pjm = task.orchestration.projectManager;
    const tl = task.orchestration.techLead;
    const qa = task.orchestration.qaEngineer;
    const mc = task.orchestration.mergeCoordinator;

    // Phase 1: Product Manager
    if (!pm || pm.status !== 'completed') {
      return 'ProductManager';
    }

    // Phase 2: Product Manager Approval
    if (!pm.approval?.approvedAt) {
      return 'ProductManagerApproval';
    }

    // Phase 3: Project Manager
    if (!pjm || pjm.status !== 'completed') {
      return 'ProjectManager';
    }

    // Phase 4: Project Manager Approval
    if (!pjm.approval?.approvedAt) {
      return 'ProjectManagerApproval';
    }

    // Phase 5: Tech Lead
    if (!tl || tl.status !== 'completed') {
      return 'TechLead';
    }

    // Phase 6: Tech Lead Approval
    if (!tl.approval?.approvedAt) {
      return 'TechLeadApproval';
    }

    // Phase 7: Cost Approval
    if (!task.orchestration.costEstimate?.approvedAt) {
      return 'CostApproval';
    }

    // Phase 8: Branch Setup
    const epics = tl.epics || [];
    const allBranchesCreated = epics.length > 0 && epics.every(e =>
      e.branches && e.branches.length > 0 && e.branches.some(b => b.pushed)
    );
    if (!allBranchesCreated) {
      return 'BranchSetup';
    }

    // Phase 9: Developers
    const allEpicsCompleted = epics.length > 0 && epics.every(e => e.status === 'completed');
    if (!allEpicsCompleted) {
      return 'Developers';
    }

    // Phase 10: QA
    if (!qa || qa.status !== 'completed') {
      return 'QA';
    }

    // Phase 11: PR Approval
    if (task.orchestration.manualReview?.status !== 'approved') {
      return 'PRApproval';
    }

    // Phase 12: Merge
    if (!mc || mc.status !== 'completed') {
      return 'Merge';
    }

    // All phases completed
    return null;
  }

  /**
   * Execute next phase for a task (ONE phase at a time)
   */
  async executeNextPhase(taskId: string): Promise<void> {
    const task = await Task.findById(taskId).populate('userId');
    if (!task) throw new Error(`Task ${taskId} not found`);

    // Start console streaming
    if (!ConsoleStreamer.isStreamingForTask(taskId)) {
      ConsoleStreamer.startStreaming(taskId);
    }

    // Determine next phase
    const nextPhaseName = this.determineNextPhase(task);

    if (!nextPhaseName) {
      console.log(`‚úÖ [Orchestration] All phases completed for task: ${task.title}`);
      task.status = 'completed';
      task.orchestration.status = 'completed';
      await task.save();
      NotificationService.emitOrchestrationCompleted(taskId);
      ConsoleStreamer.stopStreaming(taskId);
      return;
    }

    console.log(`\n‚ñ∂Ô∏è  [Orchestration] Executing phase: ${nextPhaseName}`);

    // Execute the determined phase
    await this.executeSinglePhase(nextPhaseName, task);

    console.log(`‚úÖ [Orchestration] Phase ${nextPhaseName} completed\n`);
  }

  /**
   * Execute a single phase by name
   */
  private async executeSinglePhase(phaseName: string, task: ITask): Promise<void> {
    const taskId = (task._id as any).toString();

    // Get repositories and workspace (needed for most phases)
    const repositories = await this.getRepositories(task);
    const workspacePath = await this.getOrCreateWorkspace(taskId, repositories);
    const workspaceStructure = await this.getWorkspaceStructure(workspacePath);

    // Create context
    const context = new OrchestrationContext(task, repositories, workspacePath);
    context.setData('workspaceStructure', workspaceStructure);

    // Execute phase based on name
    switch (phaseName) {
      case 'ProductManager':
        await new ProductManagerPhase(this.executeAgent.bind(this)).execute(context);
        break;

      case 'ProductManagerApproval':
        await new ApprovalPhase('Product Manager', 'orchestration.productManager').execute(context);
        break;

      case 'ProjectManager':
        await new ProjectManagerPhase(this.executeAgent.bind(this)).execute(context);
        break;

      case 'ProjectManagerApproval':
        await new ApprovalPhase('Project Manager', 'orchestration.projectManager').execute(context);
        break;

      case 'TechLead':
        await new TechLeadPhase(this.executeAgent.bind(this)).execute(context);
        break;

      case 'TechLeadApproval':
        await new ApprovalPhase('Tech Lead', 'orchestration.techLead').execute(context);
        break;

      case 'CostApproval':
        await new CostApprovalPhase().execute(context);
        break;

      case 'BranchSetup':
        await new BranchSetupPhase(this.githubService).execute(context);
        break;

      case 'Developers':
        await new DevelopersPhase(this.executeDeveloper.bind(this)).execute(context);
        break;

      case 'QA':
        await new QAPhase(
          this.executeAgent.bind(this),
          this.githubService,
          this.prManagementService,
          this.workspaceDir
        ).execute(context);
        break;

      case 'PRApproval':
        await new PRApprovalPhase().execute(context);
        break;

      case 'Merge':
        await new MergePhase().execute(context);
        break;

      default:
        throw new Error(`Unknown phase: ${phaseName}`);
    }

    // Check if phase needs approval
    const phaseResult = context.getPhaseResult(phaseName);
    if (phaseResult?.needsApproval) {
      console.log(`‚è∏Ô∏è  [Orchestration] Phase ${phaseName} requires approval - pausing`);
      return; // Stop here, wait for approval
    }

    // If phase completed and no approval needed, continue to next phase
    if (task.orchestration.autoPilotMode) {
      console.log(`üöÅ [Auto Pilot] Continuing to next phase automatically`);
      setImmediate(() => {
        this.executeNextPhase(taskId).catch(error => {
          console.error(`‚ùå Error executing next phase:`, error);
        });
      });
    }
  }

  /**
   * Helper: Get repositories for task
   */
  private async getRepositories(task: ITask): Promise<any[]> {
    if (!task.repositoryIds || task.repositoryIds.length === 0) {
      return [];
    }
    return await Repository.find({ _id: { $in: task.repositoryIds } });
  }

  /**
   * Helper: Get or create workspace for task
   */
  private async getOrCreateWorkspace(taskId: string, repositories: any[]): Promise<string | null> {
    if (repositories.length === 0) {
      return null;
    }

    const workspaceId = `task-${taskId}`;
    const baseWorkspace = path.join(this.workspaceDir, workspaceId);

    // Clone repositories if needed
    for (const repo of repositories) {
      const repoPath = path.join(baseWorkspace, repo.name);
      if (!fs.existsSync(repoPath)) {
        await this.githubService.cloneRepository(repo.full_name || repo.name, workspaceId, repo.name);
      }
    }

    return baseWorkspace;
  }

  /**
   * Helper: Get workspace structure
   */
  private async getWorkspaceStructure(workspacePath: string | null): Promise<string> {
    if (!workspacePath || !fs.existsSync(workspacePath)) {
      return '';
    }

    const items = fs.readdirSync(workspacePath);
    return items.map(item => `  - ${item}/`).join('\n');
  }

  /**
   * Orquestaci√≥n completa con team building din√°mico
   *
   * Starts orchestration by executing the first phase
   */
  async orchestrateTask(taskId: string): Promise<void> {
    return this.executeNextPhase(taskId);
  }
  /**
   * üî• NEW: Ejecuta un agente con VISIBILIDAD COMPLETA
   * Usa EnhancedAgentExecutor que captura TODO en tiempo real
   */
  private async executeAgent(
    agentType: AgentType,
    prompt: string,
    workDir: string,
    taskId?: string,
    agentName?: string,
    resumeSessionId?: string,
    forkSession?: boolean
  ): Promise<{
    output: string;
    usage: any;
    cost: number;
    sessionId: string;
    todos?: any[];
    canResume: boolean;
  }> {
    const startTime = Date.now();

    // ü™ù Hook: agent-start
    const agentStartHook = await this.hookService.executeHook('agent-start', {
      agentType,
      taskId,
      timestamp: new Date(),
    });

    if (!agentStartHook.allowed) {
      throw new Error(`Agent start blocked by hook: ${agentStartHook.message}`);
    }

    // ü™ù Hook: user-prompt-submit
    const promptHook = await this.hookService.executeHook('user-prompt-submit', {
      prompt,
      agentType,
    });

    if (!promptHook.allowed) {
      throw new Error(`Prompt blocked by hook: ${promptHook.message}`);
    }

    // Use modified prompt if hook transformed it
    const finalPrompt = promptHook.modified && promptHook.data?.prompt ? promptHook.data.prompt : prompt;

    try {
      // üî• USE NEW ENHANCED EXECUTOR FOR COMPLETE VISIBILITY
      console.log(`\nüöÄ [${agentName}] Starting with ENHANCED visibility...`);

      const result = await EnhancedAgentExecutor.executeAgent(
        agentType,
        finalPrompt,
        workDir,
        taskId || 'unknown',
        agentName || 'Agent',
        resumeSessionId ? {
          resumeSessionId,
          forkSession
        } : undefined
      );

      // Log dashboard URL for real-time viewing
      if (taskId) {
        const dashboardUrl = RealTimeLogger.getDashboardUrl(taskId);
        console.log(`üìä Real-time dashboard: ${dashboardUrl}`);
      }

      // ü™ù Hook: agent-complete
      await this.hookService.executeHook('agent-complete', {
        agentType,
        taskId,
        output: result.output.trim(),
        cost: result.cost,
        usage: result.usage,
        sessionId: result.sessionId,
        canResume: result.canResume,
      });

      // Return the result with ALL captured content
      return {
        output: result.output.trim(),
        usage: result.usage,
        cost: result.cost,
        sessionId: result.sessionId,
        todos: result.todos && result.todos.length > 0 ? result.todos : undefined,
        canResume: result.canResume,
      };
    } catch (error: any) {
      console.error(`‚ùå Error executing ${agentType}:`, error);

      // ‚ùå Record failed execution in analytics
      await this.analyticsService.recordExecution({
        taskId: taskId || 'unknown',
        agentType,
        status: 'failure',
        startedAt: new Date(startTime),
        completedAt: new Date(),
        duration: Date.now() - startTime,
        cost: 0,
        tokens: { input: 0, output: 0, cached: 0 },
        errorMessage: error.message || 'Unknown error',
      });

      throw error;
    }
  }

  /**
   * Build prompt para developers
   */
  private buildDeveloperPrompt(
    task: ITask,
    _member: ITeamMember,
    story: IStory,
    workspaceStructure: string,
    targetRepo?: any,
    allRepositories?: any[]
  ): string {
    // Extract FULL context from Product Manager
    const pmOutput = task.orchestration.productManager.output || '';

    // Extract FULL context from Tech Lead
    const techLeadOutput = task.orchestration.techLead.output || '';
    const techDesign = task.orchestration.techLead.architectureDesign || '';

    // üî• EXPLICIT REPOSITORY INSTRUCTIONS
    const repoInstructions = targetRepo
      ? `
## üéØ YOUR WORKING DIRECTORY

**YOU ARE CURRENTLY IN THE REPOSITORY: ${targetRepo.name}**

- Current working directory: \`./${targetRepo.name}/\`
- Repository URL: ${targetRepo.url || 'N/A'}
- This is the ACTUAL cloned repository
- You can DIRECTLY modify files here
- Use \`ls\` to see the files in THIS repository
- Use \`Read\`, \`Edit\`, \`Write\` tools on files in THIS directory

**CRITICAL INSTRUCTIONS:**
1. You are ALREADY inside the \`${targetRepo.name}\` repository
2. DO NOT try to "cd" into the repository - you're already there
3. Files are RIGHT HERE in your current directory
4. Just use \`ls\` to see them, then edit them directly
5. Example: \`Read src/index.ts\` will read the file in THIS repo

${allRepositories && allRepositories.length > 1 ? `
**Note:** There are ${allRepositories.length} repositories total:
${allRepositories.map(r => `- ${r.name}${r.name === targetRepo.name ? ' ‚Üê YOU ARE HERE' : ''}`).join('\n')}

If you need to modify files in other repositories, they are in \`../${allRepositories.filter(r => r.name !== targetRepo.name).map(r => r.name).join('/ or ../')}/\`
` : ''}
`
      : workspaceStructure
        ? `\n## Workspace Structure:\n\`\`\`\n${workspaceStructure}\`\`\`\n\nYou can modify files in any repository as needed.`
        : '';

    return `Act as the developer agent.

# üìã COMPLETE STORY SPECIFICATION

You are implementing a FULLY DOCUMENTED story with ALL the context you need.
DO NOT GUESS - everything is documented below by Product Manager and Tech Lead.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
## üéØ YOUR STORY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

### ${story.title}

${story.description}

**Complexity**: ${story.estimatedComplexity}
**Priority**: ${story.priority}
**Dependencies**: ${story.dependencies?.join(', ') || 'None'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
## üíº BUSINESS CONTEXT (from Product Manager)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${pmOutput ? pmOutput : 'See task description for business requirements'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
## üèóÔ∏è TECHNICAL ARCHITECTURE (from Tech Lead)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${techLeadOutput ? techLeadOutput : techDesign}

${repoInstructions}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
## ‚úÖ YOUR MISSION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Implement this story EXACTLY as documented above. You have:
1. ‚úÖ Complete business context and acceptance criteria
2. ‚úÖ Full technical specification with code examples
3. ‚úÖ Testing requirements and security considerations
4. ‚úÖ File structure and implementation guidelines

**DO NOT:**
- ‚ùå Guess or make assumptions
- ‚ùå Skip tests or documentation
- ‚ùå Ignore security requirements
- ‚ùå Deviate from architecture without reason

**DELIVERABLES:**
1. üíª Production-ready implementation (following code examples above)
2. üß™ Tests (unit + integration, >85% coverage)
3. üìù Code documentation (JSDoc comments)
4. ‚úÖ All acceptance criteria met

**WHEN DONE:**
- Verify all acceptance criteria are met
- Run tests locally
- Ensure code follows standards from Tech Lead
- Commit with clear message

You have EVERYTHING you need. Execute with precision! üöÄ`;
  }


  /**
   * Get rate limiter stats (stub for future implementation)
   */
  getRateLimiterStats(): any {
    return {
      sonnet: {
        limit: { requests: 1000, tokens: 80000 },
        usage: { requests: 0, tokens: 0 },
        available: { requests: 1000, tokens: 80000 },
      },
    };
  }

  /**
   * Resume task from checkpoint (stub for future implementation)
   */
  async resumeTask(taskId: string): Promise<void> {
    const task = await Task.findById(taskId).populate('userId');
    if (!task) throw new Error(`Task ${taskId} not found`);

    if (!task.checkpoint || !task.checkpoint.canResume) {
      throw new Error('Task cannot be resumed - no checkpoint found');
    }

    console.log(`\n‚ñ∂Ô∏è  =============== RESUMING TASK FROM CHECKPOINT ===============`);
    console.log(`üìç Resuming from phase: ${task.checkpoint.phase}`);
    console.log(`üìä Progress: ${task.checkpoint.completedStories?.length || 0} stories, ${task.checkpoint.completedEpics?.length || 0} epics completed`);
    console.log('================================================================\n');

    // Use continueOrchestrationLegacy to resume from checkpoint
    return this.continueOrchestrationLegacy(task);
  }

  /**
   * ==========================================
   * HUMAN-IN-THE-LOOP METHODS
   * ==========================================
   */

  /**
   * ‚è∏Ô∏è Check if task is paused or cancelled
   * Throws error to gracefully stop orchestration if task control action is detected
   */
  private async checkPauseOrCancel(taskId: string): Promise<void> {
    // Refresh task from database to get latest status
    const freshTask = await Task.findById(taskId);

    if (!freshTask) {
      throw new Error(`Task ${taskId} not found`);
    }

    if (freshTask.status === 'cancelled') {
      console.log(`\n‚ùå [Task Control] Task cancelled by user`);
      throw new Error('TASK_CANCELLED');
    }

    if (freshTask.status === 'paused') {
      console.log(`\n‚è∏Ô∏è  [Task Control] Task paused by user`);
      throw new Error('TASK_PAUSED');
    }

    // Also check if waiting for clarification or approval
    if (freshTask.status === 'awaiting_clarification') {
      console.log(`\nüí¨ [Task Control] Task awaiting user clarification`);
      throw new Error('AWAITING_CLARIFICATION');
    }

    if (freshTask.status === 'pending_approval') {
      console.log(`\nüë§ [Task Control] Task pending user approval`);
      throw new Error('AWAITING_USER_APPROVAL');
    }
  }

  /**
   * Save agent output for human review
   * Captures prompt, response, and any proposed changes
   */
  private async saveAgentOutput(
    task: ITask,
    agentPath: string, // e.g., 'orchestration.productManager' or 'team.0'
    output: {
      prompt: string;
      fullResponse: string;
      reasoning?: string;
      proposal?: any;
      codeChanges?: any[];
      testResults?: { passed: number; failed: number; details: string; coverage?: number; };
      evaluation?: { score: number; feedback: string; issues: string[]; };
      mergePlan?: { order: number[]; conflicts: any[]; strategy: string; };
    }
  ): Promise<void> {
    // Navigate to the correct agent in the task object
    const pathParts = agentPath.split('.');
    let agent: any = task;

    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      if (Array.isArray(agent[part])) {
        // Handle array index (e.g., team.0)
        const nextPart = pathParts[i + 1];
        agent = agent[part][parseInt(nextPart)];
        i++; // Skip next iteration since we consumed it
      } else {
        agent = agent[part];
      }
    }

    // Save the agent output
    if (!agent.agentOutput) {
      agent.agentOutput = {};
    }

    agent.agentOutput.prompt = output.prompt;
    agent.agentOutput.fullResponse = output.fullResponse;

    if (output.reasoning) {
      agent.agentOutput.reasoning = output.reasoning;
    }

    if (output.proposal) {
      agent.agentOutput.proposal = output.proposal;
    }

    if (output.codeChanges) {
      agent.agentOutput.codeChanges = output.codeChanges;
    }

    if (output.testResults) {
      agent.agentOutput.testResults = output.testResults;
    }

    if (output.evaluation) {
      agent.agentOutput.evaluation = output.evaluation;
    }

    if (output.mergePlan) {
      agent.agentOutput.mergePlan = output.mergePlan;
    }

    await task.save();
    console.log(`‚úÖ [Human-in-Loop] Saved agent output to ${agentPath}`);
  }

  /**
   * Request user approval for agent's work
   * Pauses orchestration and waits for user decision
   */
  private async requestUserApproval(
    task: ITask,
    agentPath: string,
    agentName: string,
    approvalType: 'planning' | 'code_change' | 'test_results' | 'evaluation' | 'merge'
  ): Promise<void> {
    console.log(`\n‚è∏Ô∏è  [Human-in-Loop] Requesting approval for ${agentName}...`);

    // Navigate to agent and set approval status
    const pathParts = agentPath.split('.');
    let agent: any = task;

    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      if (Array.isArray(agent[part])) {
        const nextPart = pathParts[i + 1];
        agent = agent[part][parseInt(nextPart)];
        i++;
      } else {
        agent = agent[part];
      }
    }

    // Mark agent as awaiting approval
    agent.status = 'pending';
    if (!agent.approval) {
      agent.approval = {};
    }
    agent.approval.status = 'pending';
    agent.approval.requestedAt = new Date();

    // Mark task as awaiting approval
    task.awaitingApproval = {
      stepId: agent._id || agentPath,
      agentName,
      type: approvalType,
      requestedAt: new Date(),
    };

    task.orchestration.status = 'pending_approval';
    await task.save();

    // Emit WebSocket notification
    NotificationService.notifyTaskUpdate(task._id.toString(), {
      type: 'approval_required',
      data: {
        agentName,
        approvalType,
        agentPath,
        agentOutput: agent.agentOutput,
      },
    });

    console.log(`üí¨ [Human-in-Loop] User approval required`);
    console.log(`   Agent: ${agentName}`);
    console.log(`   Type: ${approvalType}`);
    console.log(`   User must approve via API: POST /api/tasks/${task._id}/approve`);
  }

  /**
   * Check if human-in-loop mode is enabled
   * If enabled, pause for approval
   */
  private async checkAndRequestApproval(
    task: ITask,
    agentPath: string,
    agentName: string,
    approvalType: 'planning' | 'code_change' | 'test_results' | 'evaluation' | 'merge'
  ): Promise<boolean> {
    // Check if task is in human-in-loop mode
    if (task.approvalMode !== 'human-in-loop') {
      console.log(`ü§ñ [Auto Mode] Skipping approval for ${agentName}`);
      return false; // Continue without approval
    }

    // In human-in-loop mode, request approval
    await this.requestUserApproval(task, agentPath, agentName, approvalType);

    // Throw special error to pause orchestration
    throw new Error('AWAITING_USER_APPROVAL');
  }

  /**
   * Estimate number of developers needed based on task description
   */
  private estimateDeveloperCount(description: string): number {
    const lower = description.toLowerCase();

    // Keywords indicating complexity and scale
    const simpleKeywords = ['fix', 'update', 'change', 'rename', 'typo', 'style'];
    const moderateKeywords = ['add', 'create', 'implement', 'feature'];
    const complexKeywords = ['refactor', 'migrate', 'integration', 'architecture', 'system'];
    const epicKeywords = ['full', 'complete', 'entire', 'production', 'all'];

    // Count matches
    let complexity = 0;
    if (simpleKeywords.some(k => lower.includes(k))) complexity = 1;
    if (moderateKeywords.some(k => lower.includes(k))) complexity = 2;
    if (complexKeywords.some(k => lower.includes(k))) complexity = 3;
    if (epicKeywords.some(k => lower.includes(k))) complexity = 4;

    // Estimate developers based on complexity
    switch (complexity) {
      case 1: return 1;  // Simple fix - 1 developer
      case 2: return 2;  // Moderate feature - 2 developers
      case 3: return 3;  // Complex system - 3 developers
      case 4: return 4;  // Epic task - 4 developers
      default: return 2; // Default to 2 developers
    }
  }

  /**
   * Continue orchestration from where it left off (after approval)
   */
  private async continueOrchestrationLegacy(task: any): Promise<void> {
    const taskId = (task._id as any).toString();
    const startTime = Date.now();

    // Get workspace path from task (repos already cloned)
    const workspaceId = `task-${taskId}`;
    const workspacePath = path.join(this.workspaceDir, workspaceId);

    // Reconstruct repositories array
    const repositories: any[] = [];
    if (task.repositoryIds && task.repositoryIds.length > 0) {
      for (const repoId of task.repositoryIds) {
        const repo = await Repository.findById(repoId);
        if (repo) {
          const repoName = repo.githubRepoName.split('/')[1];
          repositories.push({
            id: repoId,
            name: repoName,
            fullName: repo.githubRepoName,
            path: path.join(workspacePath, repoName),
            branch: repo.githubBranch,
          });
        }
      }
    }

    const workspaceStructure = repositories.map(r => `  - ${r.name}/ (${r.fullName})`).join('\n');

    try {
      // Continue from current phase
      const currentPhase = task.orchestration.currentPhase;

      // Project Manager (if Product Manager completed but Project Manager not started)
      if (currentPhase === 'analysis' && !task.orchestration.projectManager) {
        task.orchestration.currentPhase = 'planning';
        await task.save();
        NotificationService.emitProgressUpdate(taskId, {
          completedAgents: 1,
          totalAgents: 6,
          currentAgent: 'Project Manager',
          percentage: 15,
        });
        await this.checkPauseOrCancel(taskId);
        await this.executeProjectManager(task, workspacePath, workspaceStructure);
      }

      // Tech Lead
      if (task.orchestration.projectManager?.status === 'completed' && !task.orchestration.techLead) {
        task.orchestration.currentPhase = 'architecture';
        await task.save();
        NotificationService.emitProgressUpdate(taskId, {
          completedAgents: 2,
          totalAgents: 6,
          currentAgent: 'Tech Lead',
          percentage: 30,
        });
        await this.checkPauseOrCancel(taskId);
        await this.executeTechLead(task, repositories, workspacePath, workspaceStructure);
      }

      // Development Team
      if (task.orchestration.techLead?.status === 'completed' && !task.orchestration.team) {
        task.orchestration.currentPhase = 'development';
        await task.save();
        NotificationService.emitProgressUpdate(taskId, {
          completedAgents: 3,
          totalAgents: 6,
          currentAgent: 'Development Team',
          percentage: 45,
        });
        await this.spawnDevelopmentTeam(task, repositories, workspacePath, workspaceStructure);
      }

      // QA Engineer
      if (task.orchestration.team && !task.orchestration.qaEngineer) {
        task.orchestration.currentPhase = 'qa';
        await task.save();
        NotificationService.emitProgressUpdate(taskId, {
          completedAgents: 4,
          totalAgents: 6,
          currentAgent: 'QA Engineer',
          percentage: 70,
        });
        await this.checkPauseOrCancel(taskId);
        await this.executeQAEngineer(task, repositories, workspacePath);
      }

      // Merge Coordinator
      const teamSize = task.orchestration?.team?.length || 0;
      if (teamSize > 1 && task.orchestration.qaEngineer?.status === 'completed' && !task.orchestration.mergeCoordinator) {
        task.orchestration.currentPhase = 'merge';
        await task.save();
        NotificationService.emitProgressUpdate(taskId, {
          completedAgents: 5,
          totalAgents: 6,
          currentAgent: 'Merge Coordinator',
          percentage: 85,
        });
        await this.checkPauseOrCancel(taskId);
        await this.executeMergeCoordinator(task, repositories, workspacePath);
      }

      // Mark as completed if all done
      if (task.orchestration.qaEngineer?.status === 'completed') {
        task.status = 'completed';
        task.orchestration.currentPhase = 'completed';
        await task.save();

        const duration = Date.now() - startTime;
        console.log(`‚úÖ Orchestration completed for task: ${task.title}`);
        console.log(`‚è±Ô∏è  Total duration: ${(duration / 1000 / 60).toFixed(2)} minutes`);

        NotificationService.emitOrchestrationComplete(taskId, {
          totalCost: task.orchestration.totalCost,
          totalTokens: task.orchestration.totalTokens,
          duration,
        });

        ConsoleStreamer.stopStreaming();
      }
    } catch (error: any) {
      console.error(`‚ùå Error continuing orchestration:`, error);
      task.status = 'failed';
      task.orchestration.status = 'failed';
      task.orchestration.error = error.message;
      await task.save();

      NotificationService.emitOrchestrationError(taskId, {
        error: error.message,
        phase: task.orchestration.currentPhase,
      });

      ConsoleStreamer.stopStreaming();
      throw error;
    }
  }
}
