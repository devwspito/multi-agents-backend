/**
 * Scaffolding Tools - Code generation and boilerplate tools
 * Extracted from extraTools.ts for better organization
 */

import { tool } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';

/**
 * Scaffold Test Tool
 * Generate test file skeleton for source files
 */
export const scaffoldTestTool = tool(
  'scaffold_test',
  `Generate a test file skeleton for a source file.
Use this when:
- Creating tests for existing code
- Setting up test structure for new features
- Ensuring consistent test patterns

Analyzes the source file and generates appropriate test cases.`,
  {
    sourceFile: z.string().describe('Path to the source file to test'),
    testFramework: z.enum(['jest', 'mocha', 'vitest', 'pytest']).default('jest').describe('Test framework'),
    outputPath: z.string().optional().describe('Path for test file (auto-generated if not provided)'),
    includeSnapshots: z.boolean().default(false).describe('Include snapshot tests for React components'),
  },
  async (args) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');

      const content = await fs.readFile(args.sourceFile, 'utf-8');
      const fileName = path.basename(args.sourceFile);
      const ext = path.extname(args.sourceFile);
      const baseName = path.basename(args.sourceFile, ext);
      const dir = path.dirname(args.sourceFile);

      // Parse exports/functions from file
      const exports: string[] = [];
      const functions: string[] = [];
      const classes: string[] = [];

      // Extract exports
      const exportMatches = content.matchAll(/export\s+(?:const|function|class|interface|type)\s+(\w+)/g);
      for (const match of exportMatches) exports.push(match[1]);

      // Extract functions
      const funcMatches = content.matchAll(/(?:function|const)\s+(\w+)\s*(?:=\s*(?:async\s*)?\([^)]*\)\s*(?:=>)?|<[^>]*>?\s*\([^)]*\))/g);
      for (const match of funcMatches) functions.push(match[1]);

      // Extract classes
      const classMatches = content.matchAll(/class\s+(\w+)/g);
      for (const match of classMatches) classes.push(match[1]);

      // Determine test file path
      const testPath = args.outputPath || path.join(dir, `${baseName}.test${ext}`);

      // Generate test content
      let testContent = '';

      if (args.testFramework === 'jest' || args.testFramework === 'vitest') {
        testContent = `/**
 * Tests for ${fileName}
 * @generated by scaffold_test tool
 */

import { ${exports.slice(0, 10).join(', ')} } from './${baseName}';

describe('${baseName}', () => {
${functions.slice(0, 5).map(fn => `  describe('${fn}', () => {
    it('should exist and be callable', () => {
      expect(typeof ${fn}).toBe('function');
    });

    it('should return expected result', () => {
      // TODO: Add test implementation
      expect(true).toBe(true);
    });

    it('should handle edge cases', () => {
      // TODO: Add edge case tests
    });
  });
`).join('\n')}
${classes.slice(0, 3).map(cls => `  describe('${cls}', () => {
    let instance: ${cls};

    beforeEach(() => {
      // TODO: Initialize instance
      // instance = new ${cls}();
    });

    it('should be instantiable', () => {
      // TODO: Add constructor test
      expect(true).toBe(true);
    });
  });
`).join('\n')}});
`;
      } else if (args.testFramework === 'pytest') {
        testContent = `"""
Tests for ${fileName}
@generated by scaffold_test tool
"""

import pytest
from ${baseName} import ${exports.slice(0, 10).join(', ')}


class Test${baseName.charAt(0).toUpperCase() + baseName.slice(1)}:
    """Test suite for ${baseName}"""

    def setup_method(self):
        """Set up test fixtures"""
        pass

${functions.slice(0, 5).map(fn => `    def test_${fn}_exists(self):
        """Test that ${fn} exists and is callable"""
        assert callable(${fn})

    def test_${fn}_returns_expected(self):
        """Test ${fn} returns expected result"""
        # TODO: Add test implementation
        assert True
`).join('\n')}
`;
      }

      await fs.writeFile(testPath, testContent);
      console.log(`\nðŸ§ª [Scaffold Test] Generated ${testPath}`);

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            sourceFile: args.sourceFile,
            testFile: testPath,
            framework: args.testFramework,
            analysis: {
              exports: exports.length,
              functions: functions.length,
              classes: classes.length,
            },
            message: `Test skeleton created with ${functions.length} function tests and ${classes.length} class tests`,
          }, null, 2),
        }],
      };
    } catch (error: any) {
      return { content: [{ type: 'text', text: JSON.stringify({ success: false, error: error.message }, null, 2) }] };
    }
  }
);

/**
 * Scaffold Component Tool
 * Generate component boilerplate
 */
export const scaffoldComponentTool = tool(
  'scaffold_component',
  `Generate component boilerplate.
Creates:
- Component file with proper structure
- TypeScript types/interfaces
- Basic styling file
- Optional test file

Follows project conventions automatically.`,
  {
    name: z.string().describe('Component name (PascalCase)'),
    outputDir: z.string().describe('Directory to create component in'),
    framework: z.enum(['react', 'react-native', 'vue', 'svelte']).default('react'),
    withStyles: z.boolean().default(true).describe('Include styles file'),
    withTest: z.boolean().default(true).describe('Include test file'),
    withStory: z.boolean().default(false).describe('Include Storybook story'),
    functional: z.boolean().default(true).describe('Use functional component'),
  },
  async (args) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');

      const componentDir = path.join(args.outputDir, args.name);
      await fs.mkdir(componentDir, { recursive: true });

      const createdFiles: string[] = [];

      // Generate component file
      let componentContent = '';
      let ext = '.tsx';

      if (args.framework === 'react') {
        componentContent = `/**
 * ${args.name} Component
 * @generated by scaffold_component tool
 */

import React from 'react';
${args.withStyles ? `import styles from './${args.name}.module.css';` : ''}

export interface ${args.name}Props {
  /** Component children */
  children?: React.ReactNode;
  /** Additional CSS class */
  className?: string;
}

export const ${args.name}: React.FC<${args.name}Props> = ({
  children,
  className,
}) => {
  return (
    <div className={\`${args.withStyles ? `\${styles.container}` : args.name.toLowerCase()}\${className ? \` \${className}\` : ''}\`}>
      {children}
    </div>
  );
};

export default ${args.name};
`;
      } else if (args.framework === 'vue') {
        ext = '.vue';
        componentContent = `<script setup lang="ts">
/**
 * ${args.name} Component
 * @generated by scaffold_component tool
 */

interface Props {
  /** Additional CSS class */
  className?: string;
}

defineProps<Props>();
</script>

<template>
  <div :class="['${args.name.toLowerCase()}', className]">
    <slot />
  </div>
</template>

<style scoped>
.${args.name.toLowerCase()} {
  /* Add styles */
}
</style>
`;
      }

      const componentPath = path.join(componentDir, `${args.name}${ext}`);
      await fs.writeFile(componentPath, componentContent);
      createdFiles.push(componentPath);

      // Generate styles file
      if (args.withStyles && args.framework === 'react') {
        const stylesContent = `/**
 * Styles for ${args.name}
 */

.container {
  /* Add styles */
}
`;
        const stylesPath = path.join(componentDir, `${args.name}.module.css`);
        await fs.writeFile(stylesPath, stylesContent);
        createdFiles.push(stylesPath);
      }

      // Generate test file
      if (args.withTest) {
        const testContent = `/**
 * Tests for ${args.name}
 */

import { render, screen } from '@testing-library/react';
import { ${args.name} } from './${args.name}';

describe('${args.name}', () => {
  it('renders without crashing', () => {
    render(<${args.name}>Test</${args.name}>);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('applies custom className', () => {
    const { container } = render(<${args.name} className="custom" />);
    expect(container.firstChild).toHaveClass('custom');
  });
});
`;
        const testPath = path.join(componentDir, `${args.name}.test.tsx`);
        await fs.writeFile(testPath, testContent);
        createdFiles.push(testPath);
      }

      // Generate index file
      const indexContent = `export { ${args.name}, type ${args.name}Props } from './${args.name}';\nexport { default } from './${args.name}';\n`;
      const indexPath = path.join(componentDir, 'index.ts');
      await fs.writeFile(indexPath, indexContent);
      createdFiles.push(indexPath);

      console.log(`\nðŸ§© [Scaffold Component] Created ${args.name} with ${createdFiles.length} files`);

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            component: args.name,
            framework: args.framework,
            directory: componentDir,
            files: createdFiles.map(f => f.replace(args.outputDir, '')),
            message: `Component ${args.name} created successfully`,
          }, null, 2),
        }],
      };
    } catch (error: any) {
      return { content: [{ type: 'text', text: JSON.stringify({ success: false, error: error.message }, null, 2) }] };
    }
  }
);

/**
 * Scaffold Service Tool
 * Generate service class boilerplate
 */
export const scaffoldServiceTool = tool(
  'scaffold_service',
  `Generate service class boilerplate.
Creates:
- Service class with dependency injection
- Interface definition
- Basic methods
- Optional test file

Follows clean architecture patterns.`,
  {
    name: z.string().describe('Service name (e.g., "UserService")'),
    outputPath: z.string().describe('Output file path'),
    methods: z.array(z.object({
      name: z.string(),
      async: z.boolean().default(true),
      params: z.array(z.string()).optional(),
      returns: z.string().optional(),
    })).optional().describe('Methods to generate'),
    withTest: z.boolean().default(true).describe('Generate test file'),
    singleton: z.boolean().default(true).describe('Use singleton pattern'),
  },
  async (args) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');

      const methods = args.methods || [
        { name: 'initialize', async: true, returns: 'void' },
        { name: 'getAll', async: true, returns: 'Promise<any[]>' },
        { name: 'getById', async: true, params: ['id: string'], returns: 'Promise<any | null>' },
        { name: 'create', async: true, params: ['data: any'], returns: 'Promise<any>' },
        { name: 'update', async: true, params: ['id: string', 'data: any'], returns: 'Promise<any>' },
        { name: 'delete', async: true, params: ['id: string'], returns: 'Promise<boolean>' },
      ];

      const className = args.name.endsWith('Service') ? args.name : `${args.name}Service`;
      const interfaceName = `I${className}`;

      const serviceContent = `/**
 * ${className}
 * @generated by scaffold_service tool
 */

export interface ${interfaceName} {
${methods.map(m => `  ${m.name}(${(m.params || []).join(', ')}): ${m.async ? 'Promise<' : ''}${m.returns || 'void'}${m.async && !m.returns?.startsWith('Promise') ? '>' : ''};`).join('\n')}
}

export class ${className} implements ${interfaceName} {
${args.singleton ? `  private static _instance: ${className};

  public static get instance(): ${className} {
    if (!${className}._instance) {
      ${className}._instance = new ${className}();
    }
    return ${className}._instance;
  }

  private constructor() {}
` : ''}
${methods.map(m => `
  ${m.async ? 'async ' : ''}${m.name}(${(m.params || []).join(', ')}): ${m.async ? 'Promise<' : ''}${m.returns || 'void'}${m.async && !m.returns?.startsWith('Promise') ? '>' : ''} {
    // TODO: Implement ${m.name}
    throw new Error('Not implemented');
  }`).join('\n')}
}

${args.singleton ? `export const ${className.charAt(0).toLowerCase() + className.slice(1)} = ${className}.instance;` : `export function create${className}(): ${className} {
  return new ${className}();
}`}
`;

      await fs.mkdir(path.dirname(args.outputPath), { recursive: true });
      await fs.writeFile(args.outputPath, serviceContent);

      const createdFiles = [args.outputPath];

      // Generate test file
      if (args.withTest) {
        const testPath = args.outputPath.replace('.ts', '.test.ts');
        const testContent = `/**
 * Tests for ${className}
 */

import { ${className}${args.singleton ? `, ${className.charAt(0).toLowerCase() + className.slice(1)}` : ''} } from './${path.basename(args.outputPath, '.ts')}';

describe('${className}', () => {
${args.singleton ? `  it('should be a singleton', () => {
    const instance1 = ${className}.instance;
    const instance2 = ${className}.instance;
    expect(instance1).toBe(instance2);
  });
` : ''}
${methods.slice(0, 3).map(m => `
  describe('${m.name}', () => {
    it('should be defined', () => {
      const service = ${args.singleton ? `${className}.instance` : `new ${className}()`};
      expect(service.${m.name}).toBeDefined();
    });
  });
`).join('')}
});
`;
        await fs.writeFile(testPath, testContent);
        createdFiles.push(testPath);
      }

      console.log(`\nâš™ï¸ [Scaffold Service] Created ${className}`);

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            service: className,
            files: createdFiles,
            methods: methods.map(m => m.name),
            singleton: args.singleton,
          }, null, 2),
        }],
      };
    } catch (error: any) {
      return { content: [{ type: 'text', text: JSON.stringify({ success: false, error: error.message }, null, 2) }] };
    }
  }
);

/**
 * Scaffold Model Tool
 * Generate database model boilerplate
 */
export const scaffoldModelTool = tool(
  'scaffold_model',
  `Generate database model boilerplate.
Supports:
- SQLite (better-sqlite3 with Repository pattern)
- Prisma
- TypeORM
- Plain TypeScript interfaces

Includes validation and type safety.`,
  {
    name: z.string().describe('Model name (e.g., "User")'),
    outputPath: z.string().describe('Output file path'),
    orm: z.enum(['sqlite', 'prisma', 'typeorm', 'interface']).default('sqlite'),
    fields: z.array(z.object({
      name: z.string(),
      type: z.string(),
      required: z.boolean().default(true),
      unique: z.boolean().default(false),
      default: z.string().optional(),
    })).describe('Model fields'),
  },
  async (args) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');

      let content = '';

      if (args.orm === 'sqlite') {
        const tableName = args.name.toLowerCase() + 's';
        content = `/**
 * ${args.name} Repository (SQLite with better-sqlite3)
 * @generated by scaffold_model tool
 */

import { getDb } from '../database/index.js';
import { v4 as uuidv4 } from 'uuid';

export interface ${args.name} {
  id: string;
${args.fields.map(f => `  ${f.name}${f.required ? '' : '?'}: ${f.type};`).join('\n')}
  createdAt: string;
  updatedAt: string;
}

export type Create${args.name}Input = Omit<${args.name}, 'id' | 'createdAt' | 'updatedAt'>;
export type Update${args.name}Input = Partial<Create${args.name}Input>;

export const ${args.name}Repository = {
  findById(id: string): ${args.name} | null {
    const db = getDb();
    return db.prepare('SELECT * FROM ${tableName} WHERE id = ?').get(id) as ${args.name} | null;
  },

  findAll(): ${args.name}[] {
    const db = getDb();
    return db.prepare('SELECT * FROM ${tableName} ORDER BY createdAt DESC').all() as ${args.name}[];
  },

  create(data: Create${args.name}Input): ${args.name} {
    const db = getDb();
    const id = uuidv4();
    const now = new Date().toISOString();
    db.prepare(\`
      INSERT INTO ${tableName} (id, ${args.fields.map(f => f.name).join(', ')}, createdAt, updatedAt)
      VALUES (?, ${args.fields.map(() => '?').join(', ')}, ?, ?)
    \`).run(id, ${args.fields.map(f => `data.${f.name}`).join(', ')}, now, now);
    return this.findById(id)!;
  },

  update(id: string, data: Update${args.name}Input): ${args.name} | null {
    const existing = this.findById(id);
    if (!existing) return null;
    const db = getDb();
    const now = new Date().toISOString();
    const fields = Object.keys(data).filter(k => data[k as keyof Update${args.name}Input] !== undefined);
    if (fields.length === 0) return existing;
    const setClause = fields.map(f => \`\${f} = ?\`).join(', ');
    const values = fields.map(f => data[f as keyof Update${args.name}Input]);
    db.prepare(\`UPDATE ${tableName} SET \${setClause}, updatedAt = ? WHERE id = ?\`).run(...values, now, id);
    return this.findById(id);
  },

  delete(id: string): boolean {
    const db = getDb();
    const result = db.prepare('DELETE FROM ${tableName} WHERE id = ?').run(id);
    return result.changes > 0;
  },
};
`;
      } else if (args.orm === 'prisma') {
        content = `// ${args.name} Model (Prisma schema)
// Add this to your schema.prisma file
// @generated by scaffold_model tool

model ${args.name} {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
${args.fields.map(f => `  ${f.name}     ${f.type}${f.required ? '' : '?'}${f.unique ? ' @unique' : ''}${f.default ? ` @default(${f.default})` : ''}`).join('\n')}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
`;
      } else if (args.orm === 'interface') {
        content = `/**
 * ${args.name} Interface
 * @generated by scaffold_model tool
 */

export interface ${args.name} {
  id: string;
${args.fields.map(f => `  ${f.name}${f.required ? '' : '?'}: ${f.type};`).join('\n')}
  createdAt: Date;
  updatedAt: Date;
}

export type Create${args.name}Input = Omit<${args.name}, 'id' | 'createdAt' | 'updatedAt'>;
export type Update${args.name}Input = Partial<Create${args.name}Input>;
`;
      }

      await fs.mkdir(path.dirname(args.outputPath), { recursive: true });
      await fs.writeFile(args.outputPath, content);

      console.log(`\nðŸ“¦ [Scaffold Model] Created ${args.name} (${args.orm})`);

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            model: args.name,
            orm: args.orm,
            path: args.outputPath,
            fields: args.fields.map(f => f.name),
          }, null, 2),
        }],
      };
    } catch (error: any) {
      return { content: [{ type: 'text', text: JSON.stringify({ success: false, error: error.message }, null, 2) }] };
    }
  }
);
